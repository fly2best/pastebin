
日志

日志是在进行故障回复的一个利器.
保证了数据库处于一致性状态.

undo日志

写过程
    0. 开始事务
    1. 写undo日志, 保存旧值
    2. 写数据
    3. 写commit日志记录

恢复过程
    当进行回复的时候, 倒着扫描日志.

    在扫描过程中记下所有的commit或abort的事务T.
    如果看见记录<T, x, v>
    则
    1. 如果T的commmit记录被扫描到, 则什么也不做.
    2. 否则, T 是一个未完成的事务或一个终止的事务.
        恢复管理器必须将数据库中x的值修改为v, 以防止在系统崩溃前x已经被修改.
    在做了这些修改之后, 恢复管理器必须为以前未完成的事务写入一个<Abort T>.
    然后刷新日志.

    现在数据库可以恢复正常操作操作, 开始其他事务.
    这要求扫描所有的日志, 是意见费时的操作, 因此引入了检查点的概念.
    可以参考<<数据库系统实现>>相关章节.

redo日志

undo日志的一个问题,在我们把事务改变的所有数据写到磁盘之前不能提交事务.
原因:
    如果数据没写到磁盘, 先写了commit日志,
    那么在出错恢复时, 会认为这个事务是已经完成的,
    不会做任何操作, 但其实数据是不一致的.

redo日志规则
在修改磁盘上的数据之前(一般是先修改内存中的缓存,再刷到磁盘), 要保证与X的这一修改相关的所有日志记录,
包括更新记录<T, X, v> 及 <Commit T>记录, 都必须出现在磁盘上.

利用redo日志, 我们知道如果日志中没有<Commit T>记录,
那么对数据库做操作就没有写到磁盘上, 我们可以当它压根没发生过.
对于已经提交的呢, 不知道操作的数据库没, 但是redo日志保存了我们需要的信息.

怎么恢复呢?
1. 确认以提交的事务.
2. 从首部开始扫描日志. 对遇到的的事务
    a) 如果是未提交的事务, 不用管
    b) 如果是已经提交的事务, 则redo
3. 对与每个未完成的事务T, 为数据库写入一个<ABORT T> 记录并刷新日志.

注意redo的扫描顺序是从前往后, undo是从后往前.
redo是一个操作序列, 重新来一篇的状态和事务提交后状态一致.
undo是一个撤销序列, 到着来才能恢复事务之前的状态.

redo日志的检查点建立
1. 写如日志记录<start ckpt(t1, t2,.., tk)>，其中t1, t2, tk是所有活跃的事务, 并刷新日志.
2. 将stark ckpt记录写入日志时所有已提交事务写到缓冲区但还没有写到磁盘的数据库元素写到磁盘.
3. 写入日志记录<end ckpt>并刷新日志.

对于步骤2, 要求缓冲区管理器, 知道哪些缓冲是脏的, 还需要知道哪些事务修改了哪些缓冲区.

带检查点的恢复

从后向前扫
如果先遇到end ckpt, 找到对应的start ckpt,
知道t1, t2, tk之前的事务都已经数据保存到了磁盘.
只用考虑  在t1, t2, tk之后开始的事务, 就行了.

如果先遇到start ckpt, 那么这个ckpt么有意义,
递归往前找end ckpt, 转化为先遇到end ckpt或者到日志文件开始.

undo/redo日志

undo日志要求, 先写日志，再写数据.
redo日志要求写日志之前, 所有数据必须先缓存在内存中.

这样子会有问题.
因为磁盘的读写是按照block来的, 如果A和B在同一个block上.
在是事务中访问了A,B.
假设是在undo日志中, 加入对A和B都现在内存中做了更改.
在刷新A的日志的后, 刷A的数据, 会把B刷也到磁盘上, 但这是B的日志还没刷大磁盘上去.
可能会出问题.
但似乎可以先刷所有日志, 再刷数据解决这个问题(如果这样会引起什么问题呢).

but...
如果两个事务, t1, t2, t1访问了A, t2访问了B.
则A事务提交的时候, 要求写数据, 但是不知道B事务的日志是否已经刷到磁盘.
这时候, 如果再要考虑事务之间的数据在磁盘上的分布方式, 就比较坑了.
虽然可以做, 但是会比较繁琐.

除此之外
a. undo日志要求在写commit日志记录到磁盘之前, 必须先数据到磁盘, 可能会增加i/o次数.
b. redo日志要求先日志之前，数据必须被缓存, 这会增加事务需要的平均缓存数(内存不是问题?...).
c. 如果数据库元素不是成块的, 那么在undo日志和检查点过程中redo日志在处理缓冲区方面会出现矛盾.

因此, 才提出了redo/undo日志.
记录<T, X, v, w> 事务T,将X,从v改为w.

redo/undo日志, 只有一个要求, 在改变数据库的元素之前,必须将日志写到磁盘上.
但是日志提交记录, 可以在数据写到磁盘之前或者之后.

undo/redo日志的恢复
1. 从前往后, 做已提交的事务.
2. 从后往前, 撤销为提交的事务.
因为我们允许, 已提交的事务, 数据不在磁盘上; 未提交的事务,数据可以在磁盘上.
所以这两步都是必要的.
这两步的先后顺序应该不重要.

因为undo/redo日志,在数据何时到达磁盘方面提供的灵活性, 我们可以容忍经为完成事务写入的数据写入磁盘。
所以我们能够容忍小于完整块的数据库元素, 并因此可以共享缓冲区.
我们对事务的唯一要求是:
事务在确定其不会终止之前, 不能把写入任何值(包括内存的缓冲区).
我不太理解, 这怎么起到作用的....
