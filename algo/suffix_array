
suffix_array
摘抄整理自<<后缀数组-处理字符串的有力工具-罗穗骞>

后缀数组, 所用到的数据结构:

后缀数组:
后缀数组 SA 是一个一维数组,
它保存 1..n 的某个排列 SA[1],
SA[2],......,SA[n],并且保证 Suffix(SA[i]) < Suffix(SA[i+1]),1≤i<n。
也就是将 S 的 n 个后缀从小到大进行排序之后把排好序的后缀的开头位置顺
次放入 SA 中。

名次数组:名次数组 Rank[i]保存的是 Suffix(i)在所有后缀中从小到大排
列的“名次”。

height 数组:定义 height[i]=suffix(sa[i-1])和 suffix(sa[i])的最长公
共前缀,也就是排名相邻的两个后缀的最长公共前缀。

那么对于 j 和 k,不妨设
rank[j]<rank[k], it's obvious, 有以下性质:
suffix(j) 和 suffix(k) 的 最 长 公 共 前 缀 为 height[rank[j]+1],
height[rank[j]+2], height[rank[j]+3], ... ,height[rank[k]]中的最小值。

后缀数组的算法, 就是着怎么快速计算sa, rank和 height数组.

时间复杂度:
倍增算法的时间复杂度为 O(nlogn),DC3 算法的时间复杂度为 O(n)。从常
数上看,DC3 算法的常数要比倍增算法大。
空间复杂度:
倍增算法和 DC3 算法的空间复杂度都是 O(n)。按前面所讲的实现方法,倍
增算法所需数组总大小为 6n,DC3 算法所需数组总大小为 10n。

height数组, 可以在O(n)的时间内计算出来.

具体实现, 可以参考论文.

主要来看看其应用.

1. 可重叠的最长重复子串

这道题是后缀数组的一个简单应用。做法比较简单,只需要求 height 数组
里的最大值即可。首先求最长重复子串,等价于求两个后缀的最长公共前缀的最
大值。因为任意两个后缀的最长公共前缀都是 height 数组里某一段的最小值,
那么这个值一定不大于 height 数组里的最大值。所以最长重复子串的长度就是
height 数组里的最大值。这个做法的时间复杂度为 O(n)。

2. 不可重叠的最长重复子串
这题比上一题稍复杂一点。先二分答案,把题目变成判定性问题:判断是否
存在两个长度为 k 的子串是相同的,且不重叠。解决这个问题的关键还是利用
height 数组。把排序后的后缀分成若干组,其中每组的后缀之间的 height 值都
不小于 k。

容易看出,有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然
后对于每组后缀,只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于
k。如果有一组满足,则说明存在,否则不存在。整个做法的时间复杂度为
O(nlogn)。

3. 可重叠的k次最长重复子串(pku3261)
给定一个字符串,求至少出现 k 次的最长重复子串,这 k 个子串可以重叠。
算法分析:
这题的做法和上一题差不多,也是先二分答案,然后将后缀分成若干组。不
同的是,这里要判断的是有没有一个组的后缀个数不小于 k。如果有,那么存在
k 个相同的子串满足条件,否则不存在。这个做法的时间复杂度为 O(nlogn)。


4. 不同子串的个数
给定一个字符串, 求不同的子串的个数.
算法分析:
每个子串一定是某个后缀的前缀, 那么原问题等价于求所有后缀之间的不同的前缀的个数.
如果所有的后缀按照
suffix(sa[1]), suffix(sa[2]), suffix(sa[3]), ...., suffix(sa[n])的顺序计算.
我们可以发现,

对于suffix(sa[k]), 可以产生n-sa[k]个子串(设字符串的下标从0开始), 就是这个后缀的长度.
但是会有重复的, 重复多少呢?
重复height[k]个.
因此 suffix(sa[k])将“贡献”
出 n-sa[k]-height[k]个不同的子串。
累加后便是原问题的答案。这个做法的时间复杂度为 O(n)。

5. 最长回文子串
博文已整理 
http://blog.fly2best.com/algorithm/2013/05/01/longgest-palindrome-substring/

6. 最长公共子串
这个用后缀数组来解的话, 时间复杂度可以达到O(n+m), m, n分别为两个字符串的长度.
这样, 从渐进时间复杂度上来看, 已经最优了.
至少要把两个字符串读进来吧....

是这么玩的.
注意到每个子串都是某个后缀的前缀.
这样就转化为求后缀的最长公共前缀问题.
如果直接枚举的话, 效率不行.
可以考虑用一个没有出现过的字符把两个字符串连接起来, 计算新的数组的后缀数组.
任意两个后缀的最长公共前缀, 不可能大过相邻的两个后缀的公共前缀.(为什么?想想呗)
这样求height数组的最大值就行了, 但是慢?
要保证两个后缀是属于不同的子串.
求height数组的最大值, 加个过滤条件(用下标和长度比较就能知道).
因此,如果后缀数组用O(n)的算法,那么时间复杂度可以到O(n+m).

7. 连续重复子串(pku2406)
给定一个字符串 L,已知这个字符串是由某个字符串 S 重复 R 次而得到的,求 R 的最大值

穷举字符串S的长度k, 然后判断是否满足.
判断条件
a. 判断k能否整除L
b. 然后判断suffix(k)和suffix(1)的最长公共前缀是否n-k
这个可以O(1)搞定
所以时间复杂度是O(n)的
其实, 就是判断suffix(k)是否L的前缀.

同样可以用kmp算法来做.
使用kmp计算出next数组.
if L[next[n-1]]  == L[n-1]:
    则suffix(next[n-1])是L的前缀.

根据next数组的性质, S的长度是最短的, R最大.
同样要判断len(S)是否是len(L)的一个因子.

8. 重复次数最多的连续重复子串 poj3693
给定一个字符串,求重复次数最多的连续重复子串。
算法分析:
先穷举长度l,然后求长度为l的子串最多能连续出现几次。
首先连续出现1次是肯定可以的, 所以这里只考虑至少 2 次的情况。
假设在原字符串中连续出现2次, 记这个子字符串为 str, 
那么肯定包括了字符 str[0], str[l], str[l*2], str[l*3], ......中的某相邻的两个。
所以只须看字符 str[l*i]和 str[l*(i+1)]往前和往后各能匹配到多远,
记这个总长度为k,那么这里连续出现了 k/l+1 次。
往后能匹配多远, 可以用lcp来做. rmq预处理后查询是O(1)的
往前能匹配多远, 怎么办呢...
我觉得可以字符串逆过来, 转化为lcp.

时间复杂度呢?
穷举长度 L 的时间是 n,每次计算的时间是 n/L。所以整个做法的时间复杂
度是 O(n/1+n/2+n/3+......+n/n)=O(nlogn)。

后缀数组确实是字符串处理的一个利器
时间长不弄就忘, 整理以备后需.
